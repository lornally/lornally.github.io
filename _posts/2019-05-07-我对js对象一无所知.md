> program javascript application   看了这个书, 才知道我对js对象一无所知. 感谢Eric Elliott大神. 大神为了写书, 至少弄了3个样例框架. 未来的spring啊.

###### 构造函数   竟然是不该使用的方法

虽然我也讨厌new, 可是真没想到竟然是这个结论, js使用构造函数, 就是跑偏了. 

```js
funciton car(){}
var mycar= new car; //就是这种写法不要搞.
```

###### 字面量是王道, 然而有作用域问题

- 这里其实我不是很理解, 难道不能用let规避吗?

```js
var mycar={
	color: 'pink',
	gas: function gas(){
    return this; //为了链式调用, 所有方法都要return this.
  },
}
```



###### 工厂方法

```js
//正常的工厂
var car=function car(a, b, c){
  var xxx; //这里其实声明的是一个私有变量, 不能被外部直接访问.
  return{ a,b,c, 
         br:function br(){},
        }
}

//单例工厂
function fac(){
  var x={}; //这个就是单例对象, 私有且唯一.
  return {
    get: function get(){
      return x;
    }
  }
}
var h1=fac().get();
var h2=fac().get();
//现在h1和h2其实指向同一个对象.

```



###### 工厂方法的进一步提升

```js
var carproto={
  //...省略
},
car=funciton car (op){
  return extend(object.create(carProto),op);  //感觉这里或许可以直接用object.assign
},
mycar=car({a:'a'});
```

关于工厂有一个建议, 对象和数组这种引用类型的使用要注意一下, 直接新建比较好. 

###### 相关基础知识插入 extend和object.create

extend的underscore实现, 这个实现了原型克隆.

```js
_.extend=function(ob){ //第一个参数是待处理的返回值.
	each(slice.call(arguments,1), function(source){ //把后面的每一个参数都处理为第一个参数的属性.
		for(var pr in source){
			ob[pr] =source[pr];
		}
	});
	return ob;
};
```

object.create, 这个实现了原型代理

```js
Object.create(proto, [propertiesObject])
//可以这么实现:
Object.create=function(o){
  function f(){};
  f.prototype=o;
  return new f;
}
```

共享原型模式

```js
var carproto={
  //...省略
},
car=funciton car (){
  return object.create(carProto);  //
},
mycar=car(); 
youcar=car(); //这些都是用了同样的原型.
```

###### 作者自己的库stamps

- 地址: https://stampit.js.org
- git: https://github.com/stampit-org/stampit

牛的要死, 最初的版本只有90行代码. 现在的版本有400行, 但是, 整个项目的测试代码有几千行. 腻害哦.

