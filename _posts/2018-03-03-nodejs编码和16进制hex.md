编码主要都是跟着buffer走的

- http://nodejs.cn/api/buffer.html
- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray
- buffer可以认为是typedarray的Uint8Array的一种实现, 对应于c语言的uint8_t
- 不要new, 哈哈, 正合吾意.
- 用这三个函数: `Buffer.from()`、[`Buffer.alloc()`](http://nodejs.cn/api/buffer.html#buffer_class_method_buffer_alloc_size_fill_encoding)、和 [`Buffer.allocUnsafe()`](http://nodejs.cn/api/buffer.html#buffer_class_method_buffer_allocunsafe_size) 

编码: 

- `'ascii'` - 仅支持 7 位 ASCII 数据。如果设置去掉高位的话，这种编码是非常快的。
- `'utf8'` - 多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8 。
- `'utf16le'` - 2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。
- `'ucs2'` - `'utf16le'` 的别名。
- `'base64'` - Base64 编码。当从字符串创建 `Buffer` 时，按照 [RFC4648 第 5 章](https://tools.ietf.org/html/rfc4648#section-5)的规定，这种编码也将正确地接受“URL 与文件名安全字母表”。
- `'latin1'` - 一种把 `Buffer` 编码成一字节编码的字符串的方式（由 IANA 定义在 [RFC1345](https://tools.ietf.org/html/rfc1345) 第 63 页，用作 Latin-1 补充块与 C0/C1 控制码）。
- `'binary'` - `'latin1'` 的别名。
- `'hex'` - 将每个字节编码为两个十六进制字符。

> 如果一个文件我们不知道编码, 那么就要尝试最后的三种编码

16进制hex编码显示

```js
const s="测试"
//charCodeAt可以
log(s.charCodeAt(0).toString(16))
//codePointAt也可以
for(var y=0; y<s.length; y++){	
	log(s.codePointAt(y).toString(16))
}

//貌似用正则更加简单明了.
function ASCIIToHexa (str) {
if (typeof str !== 'string') str += '';
return str.replace(/\w/g , (text) => text.charCodeAt().toString(16));
}


// int to hex 
let yourNumber=100

hexString = yourNumber.toString(16); //int to hex string


yourNumber = parseInt(hexString, 16); // hex string back to int, reverse the process

log(hexString + " ====== " + yourNumber);  

// hex to ascII
var input  = '32343630';
var output = new Buffer(input, 'hex');
log(input + " -> " + output);  // Result: 32343630 -> 2460

//或者下面用正则
var asciiVal = "32343630".match(/.{1,2}/g).map(function(v){
      return String.fromCharCode(parseInt(v, 16));
    }).join('');
    
log(asciiVal);


//一堆%的中文转码的处理, 仅仅处理了百分号
let ss=encodeURIComponent('中文编码').split('%').join('');
log(ss)
```

中文处理

```js
require('fs').createReadStream('4season.mp3').setEncoding('binary')
console.log('Line from file:', iconv.decode(line, 'gbk'))
var lineReader = require('readline').createInterface({

    
 var iconv = require('iconv-lite');

// Convert from an encoded buffer to js string.
str = iconv.decode(new Buffer([0x68, 0x65, 0x6c, 0x6c, 0x6f]), 'win1251');

// Convert from js string to an encoded buffer.
buf = iconv.encode("Sample input string", 'win1251');

// Check if encoding is supported
iconv.encodingExists("us-ascii")
    
先新建一个binary的buffer再去处理是否能有更好的结果?
```

参考

- https://github.com/ashtuchkin/iconv-lite/wiki/Supported-Encodings