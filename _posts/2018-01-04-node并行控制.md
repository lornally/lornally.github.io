> node的并行量控制是一个课题, 不节制的大量异步回调, 会导致任务栈溢出, 并且也会导致服务假死, 也就是说拿不到正确的回调参数.

方案:

1. async 回调风格
2. axios
3. mapLimit
4. eventproxy
5. Promise+bluebird
6. 原生Promise
7. Promise+co
8. Promise+async/await
9. 多个worker的思路

技术准备:

```js
fun.call(thisArg, arg1, arg2, ...) //这个比较关键, thisarg的意思是this的指向.
//call()方法接受的是若干个参数的列表，而apply()方法接受的是一个包含多个参数的数组。
         
//关于bind的展示:         
this.x = 9; 
var module = {
  x: 81,
  getX: function() { return this.x; }
};

module.getX(); // 返回 81

var retrieveX = module.getX;
retrieveX(); // 返回 9, 在这种情况下，"this"指向全局作用域

// 创建一个新函数，将"this"绑定到module对象
// 新手可能会被全局的x变量和module里的属性x所迷惑
var boundGetX = retrieveX.bind(module);
boundGetX(); // 返回 81
```

参考:

- https://github.com/magicdawn/promise.map
- https://github.com/caolan/async#queueworker-concurrency

