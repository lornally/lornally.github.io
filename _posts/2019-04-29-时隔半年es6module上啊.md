###### 如果在浏览器环境使用 import和export

js:

```js
//文件尾部
export default out;
//或者
export {out1, out2, out3};
```

###### 浏览器端也是一堆坑, 坑死人了.

```html
//引入端这么写:
<script type="module">
  import {images} from '/show/images.js'

//输出端这么写:
//export default out;
export {
    out as images
};
</script>
不要相信其他写法, 比如下面这种就怎么搞都不可以:
<script type="module" src="/show/images.js"></script>

If you export function xyz, you must import { xyz }

If you export default function xyz, you must import xyz or import { default as xyz }
```

###### type=module之后, 会导致html里面直接注册事件失败.

```html
 <input type="file" id="input" onchange="handleFiles(this.files)">
  <script type="module">
    function handleFiles() {
      alert('success') //这里不会被执行.
    }
  </script>
```

我猜测原因是: 因为type=module之后就是异步加载的了, 所以input里面写的onchange就失效了, 因为函数定义并没有被提升上去.

据说是scope问题, 我再试试.

```js
  window.handlefiles=handlefiles; //这样就解决了.
```

正解再这里: https://stackoverflow.com/questions/44590393/es6-modules-undefined-onclick-function-after-import

然后这个讲的很清楚: https://www.contentful.com/blog/2017/04/04/es6-modules-support-lands-in-browsers-is-it-time-to-rethink-bundling/



###### 在node端用es6 module

```json
// package.json
{
  "type": "module"
}
```



###### npm发布模块

```sh
#shell里面这么玩
npm publish
```

```json
//package.json要指定main, 事实上下面三个字段都是必填项目
{
  "name": "uds",
  "version": "0.0.1",
  "description": "调度算法的node版本",
	"main": "index.js",
}
```

