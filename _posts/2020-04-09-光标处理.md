> 光标处理, 需要一个总结



contenteditable的设置光标方式: 

```js
//得到光标
window.getSelection().anchorOffset;

//设置光标
window.getSelection().collapse(editor, 0);

//得到range
range = window.getSelection().getRangeAt(0); //0代表第一个拖蓝
expandedSelRange = range.cloneRange(); //range可能要改变, 比如插入node.

//设置range      
expandedSelRange.setEndAfter(lastNode);//有答案加了这一句, 因为插入range的内容是最后的node.
sel = window.getSelection();
sel.removeAllRanges();
sel.addRange(range);
```

光标处插入

```js
function insertHtmlAtCursor(html) {
  var range=window.getSelection().getRangeAt(0);
  var node = range.createContextualFragment(html);//这个有问题.
  var newNode = document.createTextNode('不用fregment???'); //这个就OK了. 
  range.deleteContents();// 某些答案用了这个. 删除了range现有内容.
  range.insertNode(node);
}
```

```js
var tagString = "<div>I am a div node</div>";
var range = document.createRange();
range.selectNode(editor); //指定插入位置editor
var documentFragment = range.createContextualFragment(tagString);
document.body.appendChild(documentFragment);
```

包裹某些内容

```js
var range = document.getSelection().getRangeAt(0);
var nnode = document.createElement("b");
range.surroundContents(nnode);
nnode.innerHTML = "Some bold text";
```

得到光标所在位置和内容

```js
var sel = document.getSelection(),
    nd = sel.anchorNode,
    text = nd.textContent.slice(0, sel.focusOffset);
var line=text.split("\n").length;
var col=text.split("\n").pop().length;
alert("row:"+line+", col:"+col )
```



## 背景: 

### range 拖蓝

###### 创建

- [`Document`](https://developer.mozilla.org/en-US/docs/Web/API/Document)var range = document.caretRangeFromPoint(float x, float y);
- [`Selection`](https://developer.mozilla.org/zh-CN/docs/Web/API/Selection) range = sel.getRangeAt(index)
- 构造函数 range = new Range()
- [`Document`](https://developer.mozilla.org/zh-CN/docs/Web/API/Document) range = document.createRange();

###### 关键属性

- range.commonAncestorContainer 返回包含startContainer` and `endContainer的最小的node.
- range.startContainer 返回包含range起点的node.
- range.endContainer 返回包含range终点的node.
- range.startOffset 在startcontianer中的range起点的位置
- range.endOffset 在endcontianer中的range终点的位置
- range.collapse 起点和终点是否重合

###### 关键方法

- range.setStart(startNode, startOffset);
- range.setEnd(endNode, endOffset);
- range.selectNode(referenceNode);  range包含整个referenceNode, range的父元素是referenceNode的父元素
- range.selectNodeContents(referenceNode); range包含referenceNode的内容, range的父元素是referenceNode
- range.collapse(toStart); 参数是bool, true收缩到起点, false收缩到终点, 默认false.
- range.insertNode(newNode);在 `Range 的`起点处插入节点。
- clone = range.cloneRange(); clone一个range.
- documentFragment = range.createContextualFragment(tagString) 纯文本没有问题.
- [Range.deleteContents()](https://developer.mozilla.org/en-US/docs/Web/API/Range/deleteContents)从dom删除range内容.
- documentFragment = range.extractContents(); 把range的内容从dom移动到一个fragment
- range.surroundContents(newParent);  把range内容包裹在newparent里面, 等于这两行语句: `newNode.appendChild(range.extractContents()); range.insertNode(newNode)`.
- range.detach(); 通知运行环境, 可以释放range.
- bool = range.intersectsNode( referenceNode ) referenceNode是否在range里面.

### selection 选区

textarea的选区方式(contenteditable失效): 

```js

contenteditable.focus() //失效, 加了tabindex都不行 devtools失效, 用按钮的点击事件就是有效地.
contenteditable.selectionStart = 100 //这个确实无效, 因为他是HTMLInputElement的属性.
contenteditable.selectionEnd = 200


textarea.focus() //成功
textarea.selectionStart = 100
textarea.selectionEnd = 200

//focus之后, 如果是devtools 都不会引起outline(蓝框), 如果是button点击事件触发, 那么篮筐outline正常


```

api命名规则

- anchor: 起点, 锚点
- focus: 终点, 焦点

###### 属性

- [`focusNode`](https://developer.mozilla.org/zh-CN/docs/Web/API/Selection/focusNode)返回该选区终点所在的节点。
- [`focusOffset`](https://developer.mozilla.org/zh-CN/docs/Web/API/Selection/focusOffset)返回一个数字，其表示的是选区终点在 [`focusNode`](https://developer.mozilla.org/zh-CN/docs/Web/API/Selection/focusNode) 中的位置偏移量。
  - 如果 focusNode 是文字节点，那么选区末尾未被选中的第一个字，在该文字节点中是第几个字（从0开始计），就返回它。
  - 如果 focusNode 是一个元素，那么返回的就是在选区末尾之后第一个节点之前的同级节点总数。
- [`rangeCount`](https://developer.mozilla.org/zh-CN/docs/Web/API/Selection/rangeCount)返回该选区所包含的range(拖蓝)的数量。

###### 关键函数

- toString()  拿到纯文本.
- sel.collapse(parentNode, offset);将当前的选区折叠为一个点。
- sel.extend(node, offset)选区焦点扩展到指定位置, 锚点不变.
- sel.modify(alter, direction, granularity) 改变选区
- sel.containsNode(aNode,aPartlyContained) 判断节点aNode是否被(部分/全部)选中.
- range处理
  - range = sel.getRangeAt(index) 返回指定的拖蓝range
  - sel.addRange(range) 添加一个range
  - sel.removeAllRanges()移除所有range, 取消所有选择.
  - sel.removeRange(range)

### node

range 的很多处理都是基于node, 因此几个关键的api需要了解

[`Node.normalize()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Node/normalize)

对该元素下的所有文本子节点进行整理，合并相邻的文本节点并清除空文本节点。

[`Node.appendChild()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Node/appendChild)

将指定的 childNode 参数作为最后一个子节点添加到当前节点。
如果参数引用了 DOM 树上的现有节点，则节点将从当前位置分离，并附加到新位置。

###### nodelist

- 是live的.

- [`Node.childNodes`](https://developer.mozilla.org/en-US/docs/Web/API/Node/childNodes) 这个属性就是

- [`document.querySelectorAll()`](https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll) 这个的返回值也是

  

###### text

- 继承链: EventTarget < Node < CharacterData < Text
- 比如某个div的childNodes就包含了它内部的文字. 
- newNode = textNode.splitText(offset), 这个函数就是拆分textnode
- document.createTextNode( "some text" )
- innerhtml也可以添加text

###### todo 待了解相关内容:

- window.getSelection
- document.createTreeWalker
- document.createElement
- document.createDocumentFragment
- Element.appendChild
- Element.className
- Node.insertBefore
- Node.removeChild
- Node.normalize
- Node.nodeType
- inputelement.selectionStart
- queryCommandState
- mutation observers
  - 这个需要缓存选择 preserving selection
  - 或许还需要处理undo manager
-  clipboard api

