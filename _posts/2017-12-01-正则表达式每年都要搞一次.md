> 去年的文档写的一点都不清晰, 导致我今年要重写一遍.

### 12圣斗士

```
需要\转义的12圣斗士: [ ] \ ^ $ . | ? * + ( )
1. [这是字符集, 选择这里面的所有的单个字符]
2. \本身就是转义符, 因此得用\\
3. ^代表一行的开始, 在[代表除...以外]
4. $匹配行尾(换行符之前的位置)
5. .任意asc码, 包含, 英文, 数字, 和几个简单符号, 不包含任意的换行符.
6. |或, a|b, 就是a或者b
7. ?*+这是西方三圣, 下面有解释.
8. (捕获符号) 每个被匹配的正则可以用\1, \2这样的项目在匹配环节指代, 到了替换环节要用$1, $2, 如此神奇的语法还是因为perl.
```

### 字符集[单聊中括号]

```
[]字符集中的4大金刚: ] \ ^ -
1. ]负责封口
2. \转义
3. ^非, 不要里面的内容. [^x] 除了x之外的所有符号
4. -代表范围, [a-z], 匹配26个小写字母.
```

### 量词{单聊大括号}

```
西方三圣: ?+*  
- 2到4次: {2,4}
- ? 0次或1次.
- +1次或多次.
- *任意次
- 一般以上的量词匹配都是贪婪的
- 任意量词的后面的?, 会导致量词变为懒惰的: *?
```

### 括号

```
括号
1. 圆括号“()”才能用于形成引用匹配组。
2. “[]”用于定义字符集。
3. “{}”用于定义重复操作。
```



### 问号

问号可以单独作为一节

```
(?:x) 匹配但是不记录在\1, \2, 或者$1, $2这种匹配项目里面
x(?=y) 匹配后面有y的x
x(?!y)匹配后面没有y的x

```

### 引用匹配(小括号最复杂)

> 前面的问号就是小括号的一部分.

```javascript
1. (xxx)代表一个匹配项目, 
2. \1, \2这种数字, 在匹配中可以用作逐个引用.
3. 替换部分要用$1, $2, 这样的, 别看我, 都是perl惹的祸. 
举例: 
var tt='barfoo把foobarfoobar'.replace(  /(foo)(bar)\1\2/, '$2 $1' );
此时 tt='barfoo把bar foo';
```

### 一大堆转义

太多了, 我们挑有用的说说.

```
\0 代表U+0000, null字符.
\0555, 代表8进制数字555.
\x56, 代表16进制数字56.
\u3838, 代表U3838, 4位的16进制字符3838.
\1, 代表重复的第一个()的匹配内容.
```

### 定位符号

```
1. 行开始和结束: ^$, 纯定位符, 同样不占位, 不消耗任何字符.
2. \b词的边界, /\bm/匹配“moon”中得‘m’；注意: JavaScript的正则表达式引擎将特定的字符集定义为“字”字符。不在该集合中的任何字符都被认为是一个断词。这组字符相当有限：它只包括大写和小写的罗马字母，小数位数和下划线字符。不幸的是，重要的字符，例如“é”或“ü”，被视为断词。 边界不占位, 纯的定位符.
3. \f 匹配换页符. 一个真实的字符. 占位的.
4. \n 换行 0A  一个真实的字符. 占位的.
5. \r 换行 0D 一个真实的字符. 占位的.
6. \s 空白字符 含空格 tab(制表符) 换页 换行,  一个真实的字符. 占位的.
7. \t 水平制表符,  一个真实的字符. 占位的.
8. \v 垂直制表符, 这货就是ctrl+k, 或者word里面ctrl+enter, 滚屏用的符号, 一般文本没有这个.

```

### 匹配模式

```
/xxx/ooo 这里的ooo就是匹配模式
1. g 全局模式, 能匹配多少就匹配多少, 否则匹配到第一个符合的就停止了.
2. i 忽略大小写模式
3. m 多行模式
4. y 继续模式, 不从头开始, 从当前位置开始匹配
例如: /xxx/gimy 也就这样了, 一共就这么四个模式标志
```



### 以js的名义

```javascript
//设置一个表达式
const regex = /ab+c/gim;
一共有6个函数, 一般exec+replace就够用了.
regexp.exec()	 匹配RegExp，返回一个数组（未匹配到则返回null）
string.replace()	 使用字符串(第二个参数)替换掉(RegExp-第一个参数, 匹配到的子字符串)。

var myRe = /d(b+)d/g;
var myArray = myRe.exec("cdbbdbsbz");
var tt='barfoo把foobarfoobar'.replace(  /(foo)(bar)\1\2/, '$2 $1' );

//处理标题, 这个也是段落的区分, 既然段落只是由于h区分, 那么段落也加在这里好了.
  var rex=/^(\#{1,6})( )([^\n]*)\n/gmi;	
  //正则表达式, 行头标志, 1-6个#必须顶着行写,  然后是任意非换行字符, 然后是一个换行字符. 
  var h_result=t.replace(rex,		 
    function(match, p1, p2, p3) {
    var ln=p1.length;
    return '<h'+ln+'>'+p3+'</h'+ln+'>\n<p>'  //很酷啊, 直接给个p段落就ok了. 
  });

```

### 贪婪和懒惰, 永远也躲不开的问题.

1. 用字符集反相匹配解决懒惰匹配问题, 用贪婪反向排除匹配更好 `[^ ooo ]`

```perl
/?!逆向断言/ #这里断言的是后面没有.
#比如不是行首
/?!^/
#前瞻断言
#正向前瞻用来检查接下来的出现的是不是某个特定的字符集。
#而负向前瞻则是检查接下来的不应该出现的特定字符串集。
#零宽断言是不会被捕获的。
(?=exp)	正向前瞻	匹配exp前面的位置
(?!exp)	负向前瞻	匹配后面不是exp的位置
(?<=exp)	正向后瞻	匹配exp后面的位置, js不支持
(?<!exp)	负向后瞻	匹配前面不是exp的位置, js不支持
所以, (?!exp)	这个全称是: 负向前瞻零宽断言, 因为js没有后瞻, 所以简称负向零宽断言
#后瞻断言
#后瞻断言也叫零宽度正回顾后发断言 (?<=表达式) 表示匹配表达式后面的位置
#例如(?<=abc).* 可以匹配abcdefg中的defg

*? #任意量词后面的?会导致前面的量词懒惰. 
var rex=/([>] )([\s\S]*?)\n\n/gmi;	#此处有两个回车结束block, 单个回车可以忽略
//这个就是>开头的任意的字符之后两个回车结尾.
```

### 技术点

```
rex=/((?!^)>)|(>(?! ))/gmi; //负向零宽断言 

var rex=/(^[>] )([\s\S]*?)\n\n/gmi;	//[\s\S]所有字符

|(或)和$1之间的关系. 
```

