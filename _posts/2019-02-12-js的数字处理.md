今天面临一个实际的需求: 

```markdown
- 欧式空间中一组点. point[i]代表第i个点.
- 用一个矩阵保留这组点的距离: distinct[i][j]这个代表i到j的距离
- 然后只保留距离每个点最近的几个点, 比如5个点.
- 造成的结果就是distinct[1][3]是有值的, 因为1的最近点有3.
- 但是 dintinct[3][1]就是一个特殊标志i, 代表他不是最近的点.
- 实际使用的时候, 如果distinct[1][3]有正常值, 那么我就要忽略distinct[3][1]中的标志值, 也就是distinct[3][1]也要当做有distinct[1][3]的值来用.
```

需求转化的描述为:

- 两个值a, i, 
  - 其中一个i不起作用.
  - aXa==a. 
  - aXi==a.
  - a为任意数字.
  - i是一个特殊数字.
  - X是一种特殊运算. 目前满足条件的是 ||.
- 最好能有一个额外的好处: 
  - 1/i==0

我的猜想和测试

1. i=infinity, X=|| 这个不成立.  iX3和3Xi的时候出了问题.
2. i=NaN, 一个满足要求的项目, 不过1/nan的加分项拿不到.
3. undefined
4. 0
5. 负infinity
6. null

这些结果都不是太满意, 忽然我灵机一动: 

- 解决问题: infinity和按位或, 解决了我的问题.
- i=infinity, X=|

