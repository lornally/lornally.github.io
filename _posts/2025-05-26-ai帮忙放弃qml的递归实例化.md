> ai帮忙, 越帮越忙

###### 缘起

* 很简单的需求, 界面上把一个树结构展示出来, 例如: 

```yaml
node:
    根:  [ 李渊 ,  李密 ]
    李渊: [ 李世民, 李元霸]
    李世民: [ 李治,  武则天]
    武则天: [ 李显, 李旦 , 李重茂, 李重俊, 李隆基 ]
```

* 然后, 所有的ai, 对, 所有的ai都犯病

##### 症状

```sh
xxx.qml is instantiated recursively
Inline components form a cycle
```

然后, 各种ai, 统统傻掉, 给的建议都是乱改. 但是, 他们症状各不相同:

1. 大部分ai经过反复尝试, 觉得根本不行, 就用load吧.
2. ds比较倔强, 他非常确认时可行的, 但是, 却给不出可以运行的代码. 他也很困惑.

###### 瞎猫碰上死耗子, 老天爷饿不死瞎家雀

* 在让ds持续简化代码的过程中, ds简化出了正确代码, 但是, 让他分析为啥正确, 他依旧在胡说八道
* 此时claude给出正确答案: delegate时, 如果隐式传递参数则没问题, 如果显式传递参数则qml引擎不接受.

```json
//正确代码
Repeater {
  model: 不重要
  delegate: 组件本身名字  //对, 你没看错, 正确代码就是这么简洁, 
}

//这里报错与众不同: Incomplete binding, expected token `:` or `{`
Repeater {
  model:  不重要
  组件本身名字 //隐式delegate也报错??? 因为没有花括号, 解析器无法判断.
  Rectangle{} //类似这样是可以的, 但是因为隐式参数不能写尾部的{}, 所以就被两头堵了.
}

//错误示例, 后面这些统一报错: is instantiated recursively 
Repeater {
  model: 不重要
  delegate: 组件本身名字{
    modelData: modelData //ai说这个传递的参数就是上面正确写法传递的参数, 但是, 这么写就报错了.
  }
}
Repeater {
  model:  不重要
  组件本身名字{} //对, 你没看错, 啥参数都不传, 加个花括号就报错了.
}

Repeater {
  model: 不重要
  delegate: 组件本身名字 { 
  	任意参数
	}
}

Repeater {
  model: 不重要
  delegate: Component {  //很多傻叉ai觉得这个很关键, 实际没屁用
    组件本身名字{这里有参数, 任何参数}
  }
}
// 这个报错也是特殊的: Inline components form a cycle
Repeater {
  model:  不重要
  组件本身名字{这里有参数, 任何参数} //隐式delegate
}

property var children:[]  // 还有傻叉ai觉得参数类型很重要. 其实完全没影响
property list<Treeds坏> children //傻叉ai认为上面的var比下面的模板类型好. 这个也是完全没影响
property var nodeData //还有傻叉ai认为不应该获得各个属性, 而应该获得统一节点, nodeData.children, nodeData.text, 这个也是完全没影响

```



###### 正确代码的含义

* 他要求隐式参数, 隐式参数的意思类似于 :sql的迭代insert语句, 
* 你要一次性把数据结构给进去, 让引擎自己解析, 
* 不能在迭代insert时添加新的参数, 那样的话很容易死循环, 所以引擎不接受.
* 这个解决方案, 干净, 简洁, 漂亮, 没毛病

#### 分锅

那么问题来了, 究竟是谁的锅?

1. qml自己要背大锅, 至少在sql等等其他声明式语言中, 处理数据结构迭代映射时, 你不会遇到这么离谱的问题. 关键他的报错太过模糊: instantiated recursively, Inline components form a cycle, 这都报的是嘛啊, 应该报错: 数据模型加载时不接受子进程附加/定制参数. 
2. ai背2锅, ds的路是对的, 还要继续强化学习. 目前看来, 编解码器是王道, 但是要提升质量, 需要更猛的强化学习. 在围棋领域, 强化学习目标就是胜利, 在生成领域, 强化学习的目标可能是: 信息密度.  目前的ai普遍都是大众水平.  并且还有扩散的问题, 扩散的目标应该是提升质量, 而不是填充废话....

#### 越想越不对劲

这个问题的出现其实非常不合理. 因为他是一个相当常见的问题, 结果搜索和教程却都失效了... 非常令人不解. 

* 只要是一个2层数组/字典, 任意的2层数据, 显示到界面上, 就会面临这个问题, 难道那么多复杂的系统, 都不用2层或者以上的数据结构? 
  * [1,[3,4]], 类似这样的数据结构很少见吗? 
  * {名字:李渊, 儿子: [李世民, 李元霸]}类似这样的就出事了, 你敢信?
  * {最爱: 猫, 它的: {姓名: 蛋挞, 品种: 金渐层}}这个层级就会面临同样的问题.
  * [1, {品种: 小熊猫}]
* qt本身又如此强大, 系统级工具, kde linux, 特斯拉机车系统, 各种游戏引擎, 大家连2维数组, 2维字典都不用吗?
* 为什么呢? 全网无结果, 为什么呢?



###### 备注: 所有的ai

* 包括: ds, claude, gemini, grok, gpt 
* 渠道包括, cline, copilot
* 表现的差异性: 
  * ds, 表现确实是最好, 瞎猫碰上死耗子就靠他了. 其他ai根本碰不上死耗子, 但是, 面对直接证据的分析, 纯纯胡说八道, 感觉他被刻板观念污染了.
  * claude, 本身的出发点是OK的, 但是如果他第一次没有帮你解决问题, 那么后续就别费劲了, 他会乱飘. 但是, 把直接证据和材料甩他脸上, 他可以分析出正确结论, 隐式参数这个核心点就是他分析出来的. 太神奇了. 但是作为瞎猫, 他基本上永远也碰不到死耗子.
  * 其他ai, 不说也罢......