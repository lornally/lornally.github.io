## 每天都要用

### gcb = git checkout -b

> 不在主线修改, 不能在主线上开发

```sh
gcb #缩写, 以当前分支为基础创建新的分支, 并且切换过去.
git checkout -b #本尊
gco #如果是已有分支, 那么需要gco.
gcm #checkout master分支.
gcd #checkout develop分支.

#如果在错误的线上开发了, 咋办?   
gsta "hellokitty" #git stash save 存一个名为hellokitty的栈
git stash #存入栈 
gb #git branch 查看一下有哪些分支.
git branch dev #这个不是切换分支, 这个是创建分支dev
gco dev #切换到dev分支.

gstl #简写, 查看stash栈的列表
git stash list #本尊.

gstp #简写, 出栈
git stash pop #本尊.
#出栈之后就可以正常提交了.

#如果在错误的分支上add了信息, 咋办? 
#系统提示: (use "git reset HEAD <file>..." to unstage)
grh filename #缩写git reset HEAD readme.md 

#问题来了
gcd #git checkout develop 切换到develop分支
gb develop #这个和上面一个有区别吗? 有的, 这个是创建了develop分支.

#另外还有这些命令
gstaa #简写, 读取栈顶, 但是, 并没有出栈, 货还在栈里面. 持续运行这个命令, 持续的可以读到栈顶的内容. 
git stash apply #本尊
gstd # 貌似是干掉顶部.
git stash drop
gstc # 清栈
git stash clear
gsts # show一堆东西
git stash show --text
gru # 缩写: 
git reset --
grhh #缩写:
git reset HEAD --hard
```

### gaa = git add

```sh
#提交之前要看状态
gst #缩写
gss #缩略展示
git status #原始命令

#add之前查看到底都改了啥
gd
git diff #原始命令
gdw #缩写, 下面是本尊, 这个命令更合理.
git diff --word-diff #详细展示一行中的修改

gco -- filename #缩写
git checkout -- application/views/campaign/index.html #放弃对这个文件的修改.

#提交修改
gaa #缩写, 并且是更为彻底的添加.
git add . #原始命令 不含删除
git add -A #原始命令 真正对应
```

### gcam = git commit

> commit之前查看缓冲区的差异

```sh
gdca #查看已缓存的改动
git diff —cached  # 这是原始命令
gd HEAD -- 2016-06-19-关于折腾字体.md #这个也行

gdt #缩写, 下面是本尊 #gitdiff系列的所有快捷键都值得试一试
git diff-tree --no-commit-id --name-only -r

```

### gp = git push

> push之前看看到底都改了啥? 
> 比如这种情况: Your branch is ahead of 'origin/dev' by 2 commits. 
> 我就想看看这两个commit是啥.

```sh
gf #git fetch是前置条件
git diff master foobar/master #比较本地分支和远程分支之间的差异
git diff HEAD...origin/master #远程分支已经修改，本地未同步的变更
git diff origin/master...HEAD #本地分支已经修改，远程未同步的变更

#远程操作
gf #缩写, 下面是本尊
git fetch
grb #缩写, 下面是本尊
git rebase
gp #缩写, 下面是本尊
git push #这个恐怕不行了, 分支控制之后, 只能pull request了.
```

### glg = git log —stat —color 定位问题

```sh
glo #或者glol先看看log情况
glgp # git log --stat --color -p  
git log -p filename #这个命令真的看到了代码变化.

#这一句最正确: 要加-c 或者 -cc
git log -c -S 'setPicture_id' app/src/main/java/com/takungae/dagong30/dgruning.java 
####################################
# 这个最正确
####################################
git log -c -S '你要搜索的字符串比如删除的那一串' 你要搜索的文件路径/你要搜索的文件名.java 

gbs #二分法定位问题 todo
git bisect


git log #
git log -p filename #这个命令真的看到了代码变化.
glg # git log --stat --color 
git log filename #这个只是历史. 没有代码变化.
glp  #_git_log_prettily
git log --pretty=oneline 文件名
# [http://www.binkery.com/archives/203.html]
git log --follow -p file
git log -- file-name 
git blame filename

# http://progit.org/book/zh/ch2-3.html


#删除的内容如何找出来: 
git log -S <string> path/to/file
#例如: 
git log -S setPicture_id app/src/main/java/com/takungae/dagong30/dgruning.java
#这个blame方法不行, 据说可以试试bisect todo
git blame --reverse START..END app/src/main/java/com/takungae/dagong30/dgruning.java
#这一句最正确: 要加-c 或者 -cc
git log -c -S 'setPicture_id' app/src/main/java/com/takungae/dagong30/dgruning.java 
####################################
# 这个最正确
####################################
git log -c -S '你要搜索的字符串比如删除的那一串' 你要搜索的文件路径/你要搜索的文件名.java 
```

### 回退 todo

> 版本库存在的意义就是可以回退, 
> 回退可以解决在错误的branch(比如被管理员锁定的master分支)提交了commit的问题.

```sh

```

### grb = git rebase

> 所有的merge都可以换成rebase

```sh
grb dev #把dev分支的内容合并回来.
grb #默认是去远程origin的对应分支.
```

gk & gke = 图形界面

> 可以替代git log的很多作用.

```sh
gk #
\gitk --all --branches
gke #
\gitk --all $(git log -g --pretty = format:%h)
```

### 不是那么常用的命令

```sh
gra #缩写, 下面是本尊
git remote add
gpu #缩写, 下面是本尊 #改变git的default remote.
gp -u <remote_name> <local_branch_name>
git init #初始化一个git目录.
#远程覆盖本地, 这个在服务器有用.
git fetch --all
git reset --hard origin/master
#不要每次都输入密码, 也是在服务器用.
git config --global credential.helper cache #linux
git config --global credential.helper osxkeychain #mac
#清掉没有跟踪的文件
gclean #git clean -df 清除文件和目录.
```

### 查看状态

```sh
gst #git status
gss #git status
git log
git branch
git blame #查看每一行都是谁改的.
grv #git remote -v

glo  #简洁显示, 没有作者.
git log --oneline --decorate --color  

glog #和glo没啥区别.
git log --oneline --decorate --color --graph  

glol #彩色log模式1, 时间, 作者都有显示.
git log --graph --pretty = format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit  

glola  #彩色log模式2, 和glol没啥区别.
git log --graph --pretty = format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --all  

gcount #缩写 按作者统计log.
git shortlog -sn #本尊

gsts # show一堆东西, stash栈里面的所有东西.
git stash show --text
gstl #简写, 查看stash栈的列表
git stash list #本尊.
```

### 不要用的命令

```sh
git merge
git pull
但是文件整体操作, add, delete, rename这三个操作, 必须快速提交.
```

参考: 

```
git help everyday
```

### git 状态基础

```sh
我们本地的git目录下, 其实分为三种类型的文件: working tree、index file和native repository;
working tree就是我们当前修改的文件;
在使用"git add"命令后, git就会把diff合入index file(通过“git diff”来查看working tree与index file的差别);
再使用"git commit"命令, 把修改合入native repository("git commit -a"相当于"git add" + "git commit"; 在commit之前, 可以通过""git diff --cached"来查看index file与commit的差别);

其实, 还可以使用"git reset"命令来还原git节点.
"git reset --hard patch-hash-name" 可以使working tree、index file以及native repository彻底回复到指定的节点;
"git reset --mixed patch-hash-name" 可以使index  file和native repository被还原;
"git reset --soft patch-hash-name" 可以使native repository被还原;
```
### 没有啥卵用的命令

```sh

glgg  #没卵用
git log --graph --color  

glgga  #卵没用
git log --graph --decorate --all  

glgm  #没啥用
git log --graph --max-count = 10  
```

