## 每天都要用

### gcb = git checkout -b

> 不在主线修改, 不能在主线上开发

```sh
gcb #缩写, 以当前分支为基础创建新的分支, 并且切换过去.
git checkout -b #本尊
gco #如果是已有分支, 那么需要gco.
gcm #checkout master分支.
gcd #checkout develop分支.

#如果在错误的线上开发了, 咋办?   
gsta "hellokitty" #git stash save 存一个名为hellokitty的栈
git stash #存入栈 
gb #git branch 查看一下有哪些分支.
git branch dev #这个不是切换分支, 这个是创建分支dev
gco dev #切换到dev分支.

gstl #简写, 查看stash栈的列表
git stash list #本尊.

gstp #简写, 出栈
git stash pop #本尊.
#出栈之后就可以正常提交了.

#如果在错误的分支上add了信息, 咋办? 
#系统提示: (use "git reset HEAD <file>..." to unstage)
grh filename #缩写git reset HEAD readme.md 

#问题来了
gcd #git checkout develop 切换到develop分支
gb develop #这个和上面一个有区别吗? 有的, 这个是创建了develop分支.

#另外还有这些命令
gstaa #简写, 读取栈顶, 但是, 并没有出栈, 货还在栈里面. 持续运行这个命令, 持续的可以读到栈顶的内容. 
git stash apply #本尊
gstd # 貌似是干掉顶部.
git stash drop
gstc # 清栈
git stash clear
gsts # show一堆东西
git stash show --text
gru # 缩写: 
git reset --
grhh #缩写:
git reset HEAD --hard
```

### gaa = git add

```sh
#提交之前要看状态
gst #缩写
gss #缩略展示
git status #原始命令

#add之前查看到底都改了啥
gd
git diff #原始命令
gdw #缩写, 下面是本尊, 这个命令更合理.
git diff --word-diff #详细展示一行中的修改

gco -- filename #缩写
git checkout -- application/views/campaign/index.html #放弃对这个文件的修改.

#提交修改
gaa #缩写, 并且是更为彻底的添加.
git add . #原始命令 不含删除
git add -A #原始命令 真正对应
```

### gcam = git commit

> commit之前查看缓冲区的差异

```sh
gdca #查看已缓存的改动
git diff --cached  # 这是原始命令
git diff --staged #和上面一样的结果.
gd HEAD -- 2016-06-19-关于折腾字体.md #这个也行, 缩写
git diff HEAD -- readme.txt #本尊


gdt #缩写, 下面是本尊 #gitdiff系列的所有快捷键都值得试一试
git diff-tree --no-commit-id --name-only -r

```

### gp = git push

> push之前看看到底都改了啥? 
> 比如这种情况: Your branch is ahead of 'origin/dev' by 2 commits. 
> 我就想看看这两个commit是啥.

```sh
gf #git fetch是前置条件
###########################################################
#这个不对, 比较出来的不知道都是啥. 
#神奇了, 测试了一下, 发现是对的.
gd
git diff master origin/master #比较本地分支和远程分支之间的差异
git diff HEAD...origin/master #远程分支已经修改，本地未同步的变更
git diff origin/master...HEAD #本地分支已经修改，远程未同步的变更

#远程操作
gf #缩写, 下面是本尊
git fetch
grb #缩写, 下面是本尊
git rebase
gp #缩写, 下面是本尊
git push #这个恐怕不行了, 分支控制之后, 只能pull request了.
```

### glg = git log —stat —color 定位问题

```sh
glo #或者glol先看看log情况
glgp # git log --stat --color -p  
git log -p filename #这个命令真的看到了代码变化.

#这一句最正确: 要加-c 或者 -cc
git log -c -S 'setPicture_id' app/src/main/java/com/takungae/dagong30/dgruning.java 
####################################
# 这个最正确
####################################
git log -c -S '你要搜索的字符串比如删除的那一串' 你要搜索的文件路径/你要搜索的文件名.java 

gbs #二分法定位问题 todo
git bisect


git log #
git log -p filename #这个命令真的看到了代码变化.
glg # git log --stat --color 
git log filename #这个只是历史. 没有代码变化.
glp  #_git_log_prettily
git log --pretty=oneline 文件名
git log --graph --pretty=oneline --abbrev-commit #查看 分支的合并情况

git log --follow -p file
git log -- file-name 
git blame filename




#删除的内容如何找出来: 
git log -S <string> path/to/file
#例如: 
git log -S setPicture_id app/src/main/java/com/takungae/dagong30/dgruning.java
#这个blame方法不行, 据说可以试试bisect todo
git blame --reverse START..END app/src/main/java/com/takungae/dagong30/dgruning.java
#这一句最正确: 要加-c 或者 -cc
git log -c -S 'setPicture_id' app/src/main/java/com/takungae/dagong30/dgruning.java 
####################################
# 这个最正确
####################################
git log -c -S '你要搜索的字符串比如删除的那一串' 你要搜索的文件路径/你要搜索的文件名.java 
```

### 回退 todo

> 版本库存在的意义就是可以回退, 
> 回退可以解决在错误的branch(比如被管理员锁定的master分支)提交了commit的问题.
> 特别好: https://tonydeng.github.io/2015/07/08/how-to-undo-almost-anything-with-git/

```sh
#先看版本, 决定回到哪个版本, 参见上面glg那个段落.
#checkout到另外应该提交的分支
gco #如果是已有分支, 那么需要gco.
gcd #checkout develop分支.
#rebase那个分支到最后的commit.
grbm #git rebase master
#回到master分支
gcm #checkout master分支.
#把master分支回退回去
git reset --hard <SHA1sum of commit N>

#版本回退
git reset --hard HEAD^ #Git中，用HEAD表示当前版本,上一个版本就是HEAD^，上上一个版本就是HEAD^^,再往上就是 HEAD~100
#或者 指定回退的commit对象的id
git reset --hard 3628164 #版本号没必要写全，git会自动找
git reflog #要重返未来，

git checkout -- readme.txt把readme.txt #文件在工作区的修改全部撤销. add之前.
#如果在错误的分支上add了信息, 咋办? 
#系统提示: (use "git reset HEAD <file>..." to unstage)
grh filename #缩写git reset HEAD readme.md 
git reset HEAD readme.txt #把暂存区的修改撤销掉（unstage）[暂存区不复存在]，重新放回工作区
```

### grb = git rebase

> 所有的merge都可以换成rebase

```sh
grb dev #把dev分支的内容合并回来.
grb #默认是去远程origin的对应分支.
git rebase
grba
git rebase --abort
grbc
git rebase --continue
grbi
git rebase -i
grbm
git rebase master
grbs
git rebase --skip
```

gk & gke = 图形界面

> 可以替代git log的很多作用.

```sh
gk #
\gitk --all --branches
gke #
\gitk --all $(git log -g --pretty = format:%h)
```

### 不是那么常用的命令

```sh
gra #缩写, 下面是本尊
git remote add
gpu #缩写, 下面是本尊 #改变git的default remote.
gp -u <remote_name> <local_branch_name>
git init #初始化一个git目录.
#远程覆盖本地, 这个在服务器有用.
git fetch --all
git reset --hard origin/master
#不要每次都输入密码, 也是在服务器用.
git config --global credential.helper cache #linux
git config --global credential.helper osxkeychain #mac
#清掉没有跟踪的文件
gclean #git clean -df 清除文件和目录.
#解除某些文件的跟踪状态
git rm --cached readme.md
git branch -d dev  # 删除dev分支
gb -d dev # 缩写
git config --global color.ui true # Git显示颜色，会让命令输出看起来更醒目

echo "*.txt" > .gitignore #忽略txt文件   这个是替换.gitignore文件, 要找个办法是添加.gitignore.
echo '*.log' >> .gitignore #忽略文件里面添加一行
```

### 查看状态

```sh
gst #git status
gss #git status

gb #缩写
git branch
gba #缩写 = gb + gbr
git branch -a #所有的分支, 包括远程的.
gbr #缩写
git branch --remote

####下面两个不知道啥意思.
gbda
gbnm

gbl filename #缩写: git blame -b -w
git blame #查看每一行都是谁改的.

grv #git remote -v
git remote -v
gr show #缩写
git remote show #本尊

###################################################################
###参考上面的glg段落.

glo  #简洁显示, 没有作者.
git log --oneline --decorate --color  

glog #和glo没啥区别.
git log --oneline --decorate --color --graph  

glol #彩色log模式1, 时间, 作者都有显示.
git log --graph --pretty = format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit  

glola  #彩色log模式2, 和glol没啥区别.
git log --graph --pretty = format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --all  

gcount #缩写 按作者统计log.
git shortlog -sn #本尊

glp  #_git_log_prettily
git log --pretty=oneline 文件名
git log --graph --pretty=oneline --abbrev-commit #查看 分支的合并情况
##################################################################################
gsts # show一堆东西, stash栈里面的所有东西.
git stash show --text
gstl #简写, 查看stash栈的列表
git stash list #本尊.

git tag # 查看标签列表
```

### 不要用的命令

```sh
git merge
git pull
但是文件整体操作, add, delete, rename这三个操作, 必须快速提交.
```

参考: 

```
git help everyday
http://www.jianshu.com/p/adbaa9f56f5d
http://progit.org/book/zh/ch2-3.html
http://www.binkery.com/archives/203.html
```

### git 状态基础

```sh
我们本地的git目录下, 其实分为三种类型的文件: working tree、index file和native repository;
working tree就是我们当前修改的文件;
在使用"git add"命令后, git就会把diff合入index file(通过“git diff”来查看working tree与index file的差别);
再使用"git commit"命令, 把修改合入native repository("git commit -a"相当于"git add" + "git commit"; 在commit之前, 可以通过""git diff --cached"来查看index file与commit的差别);

其实, 还可以使用"git reset"命令来还原git节点.
"git reset --hard patch-hash-name" 可以使working tree、index file以及native repository彻底回复到指定的节点;
"git reset --mixed patch-hash-name" 可以使index  file和native repository被还原;
"git reset --soft patch-hash-name" 可以使native repository被还原;
git 工作区 和暂存区 各个分支用的是同一个，仅仅提交的时候由于指针指的地方不同，令我们感觉似乎在不同区间上面工作，且git限定我们 工作区间被修改(如 index.jsp 被修改或被git add但是未 commit) 此时 git是不允许git checkout （切换分支的）
```
### 没有啥卵用的命令

```sh
glgg  #没卵用
git log --graph --color  
glgga  #卵没用
git log --graph --decorate --all  
glgm  #没啥用
git log --graph --max-count = 10  
```

