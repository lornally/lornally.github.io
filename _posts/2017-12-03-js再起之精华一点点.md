> js的精华其实可以压缩成一点点.

### 三位一体: 数组, 集合, 函数

> 这三个其实是同一个东西

```javascript
//函数, 他其实是特殊的function集合
var square = function(number) { //一般都用这个定义.
	return number * number; 
};

//集合, 看到了吗? 他仅仅是没有声明为function而已
var animal = { //大括号方式定义集合.
  type: "Invertebrates", // 属性
  displayType : function() {      console.log(this.type);  } 
}
// 数组, 他其实就是有默认序号的集合.
var arr = ['red', 'green', 'blue'];
arr.foo = "hello";

//函数的数组, 下面的数组, 每个都是一个函数.
var af = [
  function(string) {  // do something
  },
  sf=function(string) {    console.log('second');  },  
]
af[1]('oo'); 
af["length"];  // 2 可以直接用中括号访问属性.
animal['displayType']();
//下面这句就通不过了, 因为array不支持键值对的这种方式声明.
var appp=[0:333, 1:5555];

//.和[]是一样的东西
var obj = {
    key1: value1,
    key2: value2
};
//Using dot notation:
obj.key3 = "value3";
//Using square bracket notation: 这里key可以是个变量. 这就是js牛的地方.
obj["key3"] = "value3";


```

### 进步一丢丢: 推导式和胖箭头

```javascript
// 推导式: 
var numbers = [1, 2, 3, 21, 22, 30];
var doubledEvens = [i * 2 for (i of numbers) if (i % 2 === 0)];
console.log(doubledEvens); // logs 4,44,60
// 胖箭头: 
numbers.forEach((color)=>{console.log(color);});
```

### 基于prototype的设计真的很functional

```javascript
//这样就成功了, 这个递归很有趣, 函数名x并不是用来递归的名字量, 递归的名字量相反了是变量s.
Number.prototype.s = function x() { 
 var n=this.valueOf();
  if ((n < 2))   return 1;
  else    return (n * (n-1).s());
} ;
(5).s();

//去掉递归, 可以看这个简单的例子.
Number.prototype.r = function() {
    return Math.round(this.valueOf());
};
(5.5).r(); //第一种形式
5..r(); //第二种形式, 不能有小数点了.
5.5["r"](); //第三种当做数组属性处理的形式. 

//针对array更简单了.
var colors = ['red', 'green', 'blue'];
Array.prototype.s = function x() { 
  	this.forEach(function(color) {
 		 console.log(color);
	});
} 
colors.s();
```

