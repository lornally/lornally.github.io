> python类型

#### enum类型

- 从 Python 3.4 起，标准库自带 `enum` 模块，里面提供 `Enum / IntEnum / Flag / IntFlag` 等**真正的类型**，所以：
  → **enum 是 Python 原生的内置类型**，只是放在标准库，需 `from enum import Enum` 再继承使用。
- 它跟 C/Java 的 enum 类似，但功能更丰富：
  – 成员自带 `.name` `.value` 属性；
  – 可迭代、可比较、可哈希；
  – 支持 `auto()` 自动赋值、`@unique` 强制唯一、`Flag` 位运算等进阶玩法 

```py
from enum import Enum, auto

class State(Enum):
    READY = auto()
    RUN   = auto()
    DONE  = auto()

print(State.RUN.name)   # → 'RUN'
print(State.RUN.value)  # → 2
```

------------------------------------------------
### 更多类型

1. 枚举（enum)

------------------------------------------------
```python
from enum import Enum, IntEnum, Flag, IntFlag, auto

class Kind(Enum):          # 值可以是任意类型
    A = 1
    B = 'bbb'

class State(IntEnum):      # 同时是 int 子类，可与数字直接比较
    READY = auto()         # 自动 1,2,3…
    RUN   = auto()
print(State.READY == 1)    # True

class Align(Flag):         # 支持 | & ^ ~
    LEFT  = 1
    RIGHT = 2
    CENTER = LEFT | RIGHT
print(Align.CENTER)        # Align.CENTER  值=3
```
PySide6 的 `QEvent.Type`、`Qt.AlignmentFlag` 等就是用 **IntFlag** 自动生成的，所以既能当整数传参，又能 `.name` 打印。

------------------------------------------------
2. 类型提示 & 静态检查——写错即爆红
------------------------------------------------
```python
from typing import List, Optional, Union, Dict

def move(pts: List[QPointF], dx: float) -> None:
    ...

# Qt 6.5+ 官方 stub 已经带完整注解，VS Code + pylance 会实时报错
```
搭配 **mypy** 或 **pylance** 能在运行前发现参数传错。

------------------------------------------------
3. 数据类（dataclass）—— 不用写 boilerplate
------------------------------------------------
```python
from dataclasses import dataclass

@dataclass(slots=True)      # 3.10+ 支持 slots，内存对标 C++ struct
class Texture:
    name: str
    size: QSize
    id_: int
```
自动获得 `__init__/__repr__/__eq__`，比 `namedtuple` 灵活。

------------------------------------------------
4. 只读结构（NamedTuple + typing.NamedTuple）
------------------------------------------------
```python
from typing import NamedTuple

class Vertex(NamedTuple):
    x: float
    y: float
```
可索引、可解包、不可变，做常量表极快。

------------------------------------------------
5. 联合类型（Union / |）—— 一参多型
------------------------------------------------
```python
# 3.10+ 写法
def set_pen(color: QColor | Qt.GlobalColor | str) -> None:
    ...
```
静态检查器会确保三种类型都能进。

------------------------------------------------
6. NewType —— 给 int/str 加语义标签，零运行时开销
------------------------------------------------
```python
from typing import NewType
UserId = NewType('UserId', int)
def query(uid: UserId) -> str: ...
# 传普通 int 会报错，但运行仍是 int，速度无损
```

------------------------------------------------
7. 运行时类型检查 —— 比 enum 更狠的 `enum.check`
------------------------------------------------
```python
from enum import verify, UNIQUE

@verify(UNIQUE)
class Code(IntEnum):
    OK = 0
    FAIL = 1
```
若值重复会 **import 阶段就抛异常**，提前暴露错误。

------------------------------------------------
8. 位域总结 —— 对标 C++ flag
------------------------------------------------
`IntFlag` 成员可任意组合，自带 `__or__/__and__/__invert__`，PySide6 全部 Qt flag 都是这种实现，所以你能写：

```python
align = Qt.AlignLeft | Qt.AlignVCenter
if align & Qt.AlignLeft:
    ...
```

------------------------------------------------
9. 一句话速记
------------------------------------------------
- **enum** 让常量“有名字、可打印、可位运算”；  
- **dataclass / NamedTuple** 让结构体“零样板、可比较”；  
- **typing** 让参数“写错即爆红”，却 **零运行时成本**；  
- 全部功能 **CPython 自带**，无需第三方库，速度对标手写代码。

总结:

python类似c++一样走在了错误的道路上, 这条路的尽头是java, 有无数的数据类型, 但是, 没有真正好用的数据类型. 数据类型需要的不是类型的花样, 而是语法结构的一致性. 上面这些类型大部分都是dic/object的特殊形式, 统一字典/枚举/数组等等所有类型为一个语法才是王道.
