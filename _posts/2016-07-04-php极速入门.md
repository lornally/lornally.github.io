> 正确源自错误, 失败是成功她妈, 先来个错误的: i=100; echo "xxx"+i; 

### 语法

1. php声明变量需要$开头, 常量不需要. 因此:

   ```php
   $i=100;
   define("FOO",     "something"); //这是一个正常的常量, 不在类范围内的.
   ```

2. php的字符串链接用点 __.__ , 因此: 

   ```php
   echo "xxx".i
   ```

   这样写就对了.

### 这货竟然是functional的.


1. 可变变量. 

   ```php
   $hello='hello world';
   $b='hello';
   echo $$b; //此处显示hello world.
   ${$a[1]}; //数组有歧义, 因此必须大括号使用.
   ${$a}[1];
   ```

   ​

2. 可变函数.

   ```php
   function foo() {
       echo "In foo()<br />\n";
   }
   $c = 'foo';
   $c();        // This calls foo()
   class Foo
   {
       function Variable()
       {
           $name = 'Bar';
           $this->$name(); // This calls the Bar() method
       }

       function Bar()
       {
           echo "This is Bar";
       }
   }

   $o = new Foo();
   $funcname = "Variable";
   $o->$funcname();   // This calls $foo->Variable()
   ```

   ​

3. 万物皆有值. 没写↩︎的函数返回的是null.

4. 闭包(匿名函数).

   ```php
   $greet = function($name)
   {
       printf("Hello %s\r\n", $name);
   };

   $greet('World');
   $greet('PHP');
   ```

   ​

5. 支持递归, 因此, 我们可以设计迭代函数.

6. 函数的参数可以传引用, 这样参数就会在函数中进行修改. 比如&$i 

   ```php
   $greet = function($name)
   {
       printf("Hello %s\r\n", $name);
   };

   $greet('World');
   $greet('PHP');
   ```

   ​

OO

1. 水平组合

   ```php
   trait ezcReflectionReturnInfo {
       function getReturnType() { /*1*/ }
       function getReturnDescription() { /*2*/ }
   }

   class ezcReflectionMethod extends ReflectionMethod {
       use ezcReflectionReturnInfo;
       /* ... */
   }

   class ezcReflectionFunction extends ReflectionFunction {
       use ezcReflectionReturnInfo;
       /* ... */
   }
   ```

2. 静态和常量 const和static, __->__ 和 __::__ 

   ```php
   //在类的成员方法里面，可以用 ->（对象运算符）：$this->property（其中 property 是该属性名）这种方式来访问非静态属性。静态属性则是用 ::（双冒号）：self::$property 来访问。
   define("FOO",     "something"); //这是一个正常的常量, 不在类范围内的.
   class MyClass
   {
       const constant = 'constant value'; //这个是常量, 注意它并没有使用$声明
     public static $my_static = 'foo'; //这个是静态的

       function showConstant() {
           echo  self::constant . "\n";
       }
         public static function aStaticMethod() {
           // ...
       }

   }
   print MyClass::$my_static . "\n"; //这个是访问静态属性的方法, 用类名直接访问.
   MyClass::aStaticMethod(); //访问静态方法
   echo MyClass::constant . "\n"; //常量
   $classname = "MyClass";
   echo $classname::constant . "\n"; // 自 5.3.0 起, 常量访问.
   $classname::aStaticMethod(); // 自 PHP 5.3.0 起, 静态方法.

   $class = new MyClass();
   $class->showConstant(); //正常的类方法.
   echo $class::constant."\n"; // 自 PHP 5.3.0 起, 常量.
   ```


### 数组array, 变量要加$

1. 竟然有三种赋值方法

   ```php
   //前面这三种可能会引起问题, 如果这个变量曾经定义过的话.
   //因为string 中的字符可以通过一个从 0 开始的下标，用类似 array 结构中的方括号包含对应的数字来访问和修改，比如 $str[42]。可以把 string 当成字符组成的 array

   //第一种, 直接赋值.
   $xxx[]="hhh";
   $xxx[]="hhhh";
   $xxx[]="hhhhh";

   //第二种, 直接赋值, 并且指定索引下标
   $xx[0]="hhh";
   $xx[1]="hhhh";
   $xx[2]="hhhhh";

   //或者创建一个关联数组, 
   $x['lh0']="hhh";
   $x['mh1']="hhhh";
   $x['hh2']="hhhhh";



   //用array的唠叨丑陋模式
   $yxxx=array(
     'hhh',
     'hhhh',
     'hhhhh'
   );
   $xzxx=array(
    'lh'=> 'hhh',  // =>这么神奇的符号, 就这么一个作用哈. 
     'mh'=>'hhhh',
    'hh'=> 'hhhhh'
   );
   // 自 PHP 5.4 起 有了新的不唠叨格式, 貌似这个是最不唠叨格式.
   $arr= [
       "foo" => "bar",
       "bar" => "foo",
   ];
   ```

2. 关于赋值, 添加, 删除, 就比较有趣了.

   ```php
   //unset() 函数允许删除数组中的某个键。但要注意数组将不会重建索引。如果需要删除后重建索引，可以用 array_values() 函数。
   $arr = array(5 => 1, 12 => 2);

   $arr[] = 56;    // This is the same as $arr[13] = 56;
                   // at this point of the script

   $arr["x"] = 42; // This adds a new element to
                   // the array with key "x"
                   
   unset($arr[5]); // This removes the element from the array, 

   unset($arr);    // This deletes the whole array

   // 创建一个简单的数组
   $array = array(1, 2, 3, 4, 5);
   print_r($array);

   // 现在删除其中的所有元素，但保持数组本身不变:
   foreach ($array as $i => $value) {  //foreach 控制结构是专门用于数组的。它提供了一个简单的方法来遍历数组。
       unset($array[$i]);
   }
   print_r($array);

   // 添加一个单元（注意新的键名是 5，而不是你可能以为的 0）
   $array[] = 6;
   print_r($array);

   // 重新索引：
   $array = array_values($array);
   $array[] = 7;
   print_r($array);


   ```

3. 示例

   ```php
   // This:
   $a = array( 'color' => 'red',
               'taste' => 'sweet',
               'shape' => 'round',
               'name'  => 'apple',
               4        // key will be 0
             );

   $b = array('a', 'b', 'c');

   // . . .is completely equivalent with this:
   $a = array();
   $a['color'] = 'red';
   $a['taste'] = 'sweet';
   $a['shape'] = 'round';
   $a['name']  = 'apple';
   $a[]        = 4;        // key will be 0

   $b = array();
   $b[] = 'a';
   $b[] = 'b';
   $b[] = 'c';

   // After the above code is executed, $a will be the array
   // array('color' => 'red', 'taste' => 'sweet', 'shape' => 'round', 
   // 'name' => 'apple', 0 => 4), and $b will be the array 
   // array(0 => 'a', 1 => 'b', 2 => 'c'), or simply array('a', 'b', 'c').
   ```

4. 可以传引用

   ```php
   $arr1 = array(2, 3);
   $arr2 = $arr1;
   $arr2[] = 4; // $arr2 is changed,
                // $arr1 is still array(2, 3)
                
   $arr3 = &$arr1;
   $arr3[] = 4; // now $arr1 and $arr3 are the same
   ```

   ​

### sdk

1. 是否使用sdk, 我也不知道, 可以试试phpstorm
2. 注册时选择License server，填http://idea.lanyus.com，然后点击OK，就注册了
3. 此方法是在IDEA15评论中看到的，试了一下PHPSTORM10，一样可用。

### 官网

php官网: http://php.net/manual/zh/internals2.memory.php

注册参考: http://www.oschina.net/news/67681/phpstorm-10